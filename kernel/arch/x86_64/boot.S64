#include "multiboot2header.S"
# Reserve a stack for the initial thread.
.global stackTop
.section .bss
.align 16
stackBottom:
.skip 131072 # 128K of stack
stackTop:
# The kernel entry point.
.section .text
.global _start
.type _start, @function
_start:
	cli
	movq $stackTop, %rsp
	pushq %rbx
	pushq %rax
	call _bootmsg

	# Call the global constructors.
	call _init
	movb $0xFE, 56(%rdx) # .
	movb $0x06, 57(%rdx) # brown (orange)
	# Initialize the floating point unit.
	finit
	movb $0xFE, 58(%rdx) # .
	movb $0x0E, 59(%rdx) # yellow
	# TODO: Initialize the PIC and PIT
	
	### FIXME: might be useless as bootboot enables it for us ###	
	# # Check if A20 Gate is already enabled from grub 
	# call pushall
	# mov $0x112345, %rdi  # odd megabyte address.
	# mov $0x012345, %rsi  # even megabyte address.
	# mov %rsi, (%rsi)     # making sure that both addresses contain diffrent values.
	# mov %rsi, (%rsi)     # (if A20 line is cleared the two pointers would point to the address 0x012345 that would contain 0x112345 (edi)) 
	# cmpsd             # compare addresses to see if the're equivalent.
	# call popall
	# movb $0xFE, 60(%edx) # .
	# movb $0x0A, 61(%edx) # lightgreen
	# call pushall
	# jne __bootstg2 # if A20 is on, jmp to call boot stage2.
	# call popall
	# # Enable A20 Gate if it's not enabled.
	# in $0x92, %al
	# or $2, %al
	# out %al, $0x92
	jmp __bootstg2

nofpu:
	mov $0x0, %rax
	ret

__bootstg2:
	movb $0xFE, 62(%rdx) # .
	movb $0x02, 63(%rdx) # green
	call _disableCursor
	# call _checkForLongModeCPUID # Call a function that checks if we have 64-bit long mode availible by using the `cpuid` instruction
	movb $0xFE, 64(%rdx) # .
	movb $0x01, 65(%rdx) # blue
	movb $0xFE, 66(%edx) # .
	movb $0x09, 67(%edx) # lightblue
	# Just in case interrupts are enabled, disable them.
	cli
	# Also just in case, clear all the regs
	xor %eax, %eax
	xor %ebx, %ebx
	xor %ecx, %ecx
	xor %edx, %edx
	xor %esi, %esi
	xor %edi, %edi
	xor %ebp, %ebp
	# Transfer control to the main kernel.
	movb $0xFE, 68(%edx) # .
	movb $0x03, 69(%edx) # yellow
	call kernelMain

	# Hang if kernelMain unexpectedly returns.
	cli
	mov $0xFE, %al
	out %al, $0x40
halt:
	hlt
	jmp halt
.size __bootstg2, . - _start
